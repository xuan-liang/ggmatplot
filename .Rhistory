knitr::opts_chunk$set(echo = TRUE, tidy = TRUE)
x <- rnorm(100,sd=2)
x
y <- x*0.5+rnorm(100,sd=1)
fit.y <- fitted(lm(y~x))
p <- ggmatplot(x,cbind(y,fit.y))
source("ggmatplot1.R")
p <- ggmatplot(x,cbind(y,fit.y))
source("ggmatplot.R") # Plot function without ... option as an argument
p <- ggmatplot(x,cbind(y,fit.y))
source("ggmatlist.R") # The function is to convert a list to a matrix
source("ggmatclean.R") # The function is to transfrom a wide format data to a long format data
source("ggmatplot.R") # Plot function without ... option as an argument
source("getoption.R") # Used in ggmatplot1() function to extract what arguments can be allowed in a function of ggpubr, for example, I only tried it for plot.type "histogram".
source("ggmatplot1.R")
library(tidyverse)
library(ggpubr)
p <- ggmatplot(x,cbind(y,fit.y))
p
class(p)
p
p <- ggmatplot(x,cbind(y,fit.y))
p
p
p
library(tidyverse)
library(ggpubr)
source("ggmatlist.R") # The function is to convert a list to a matrix
source("ggmatclean.R") # The function is to transfrom a wide format data to a long format data
source("ggmatplot.R") # Plot function without ... option as an argument
source("getoption.R") # Used in ggmatplot1() function to extract what arguments can be allowed in a function of ggpubr, for example, I only tried it for plot.type "histogram".
source("ggmatplot1.R")
x <- rnorm(100,sd=2)
y <- x*0.5+rnorm(100,sd=1)
fit.y <- fitted(lm(y~x))
cbind(y,fit.y)
ggmatplot(x,cbind(y,fit.y))
p <- ggmatplot(x,cbind(y,fit.y))
p
p
X <- 1:10
Y <- X^2
Z <- X^2-2*X
Z
cbind(Y,Z)
ggmatplot
ggmatplot(X,cbind(Y,Z), shape = c(16,1),legend_label =  c("X^2","X^2-2*X"),plot.type = "line")
lineplot <- ggmatplot(X,cbind(Y,Z), shape = c(16,1),legend_label =  c("X^2","X^2-2*X"),plot.type = "line")
lineplot
bothplot <- ggmatplot(X,cbind(Y,Z), shape = c(16,1),legend_label =  c("X^2","X^2-2*X"),plot.type = "both")
bothplot
iris_sub <- subset(iris, Species == "setosa")
iris_sub
ggmatplot(iris_sub[1:4], plot.type = "density")
ggmatlist <- function (x){
max.length <- max(sapply(x, length))
x <- lapply(x, function(v) { c(v, rep(NA, max.length-length(v)))})
x<- do.call(cbind, x)
}
ggmatlist(c91,2,3,4,5,6)
list1 <- c(1,3,5,7,3,6,7)
list1
class(list1)
ggmatlist(list1)
x <- ggmatlist(list1)
x
max(sapply(list1, length)
)
l1 <- c(1,2,3,4,5,6,7,8)
max(sapply(l1, length))
sapply(l1, length)
l1 <- c((1,2,3,4,5,6,7,8),(1,2,3,4,5,6,7,8))
l1 <- c(c(1,2,3,4,5,6,7,8),c(1,2,3,4,5,6,7,8))
sapply(l1, length)
l1 <- c(1,2,3,4,5,6,7,8)
max(sapply(l1, length))
list(1,2,3)
list(c(1,2,3))
list(c(1,2,3),c(4,5,6))
l1 <- list(c(1,2,3),c(4,5,6))
sapply(l1, length)
l1 <- list(c(1,2),c(4,5,6))
sapply(l1, length)
max(sapply(l1, length))
max.length <- max(sapply(l1, length))
lapply(l1, function(v) { c(v, rep(NA, max.length-length(v)))})
rep(NA, max.length-length(v))
function(v) { c(v, rep(NA, max.length-length(v))
)
)
rep(NA, max.length-length(l1))
length(l1)
l1 <- list(c(1,2),c(4,5,6),c(5,6,3))
max.length <- max(sapply(l1, length))
max.length
rep(NA, max.length-length(l1))
rep(NA, max.length-length(l1))
max.length-length(l1)
l1 <- list(c(1,2),c(4,5,6,4),c(5,6,3))
max.length <- max(sapply(l1, length))
rep(NA, max.length-length(l1))
lapply(l1, function(v) { c(v, rep(NA, max.length-length(v)))})
do.call(cbind, x)
do.call(cbind, l1)
l1 <- lapply(l1, function(v) { c(v, rep(NA, max.length-length(v)))})
do.call(cbind, l1)
is.list(l1)
ggmatlist(l1)
y <- ggmatlist(l1)
y
data.frame(l1)
data.frame(y)
y <- data.frame(y)
y
ncol(y)
x <- rnorm(100,sd=2)
y <- x*0.5+rnorm(100,sd=1)
fit.y <- fitted(lm(y~x))
ggmatclean(x)
x
li
ggmatlist <- function (x){
max.length <- max(sapply(x, length))
x <- lapply(x, function(v) { c(v, rep(NA, max.length-length(v)))})
x<- do.call(cbind, x)
}
ggmatlist(x)
x <- ggmatlist(x)
x
is.list(x)
# Default plot type: Scatterplot
x <- rnorm(100,sd=2)
is.list(x)
data.frame(x)
x <- data.frame(x)
x
ncol(x)
missing(x)
finY <- cbind(y,fit.y)
finY
missing(finY)
as.data.frame(finY)
ncol(as.data.frame(finY))
ggmatclean <- function (x, y){
if(is.list(x)){
x <- ggmatlist(x)
}
x <- data.frame(x)
ncolx <- ncol(x)
if (!missing(y)){
ncoly <- ncol(as.data.frame(y))
y <- data.frame(y)
}else{
ncoly<-1
}
if (missing(y)){
data <- mutate(x, Observation_number = 1:n()) %>% gather(key = "Group", value = "yy", -(ncolx+1))
xname <- "Observation_number"
yname <- "yy"
group <- "Group"
}else if(ncolx>ncoly&ncoly==1){
data <- data.frame(x,y)
ncol <- ncol(data)
yname <- colnames(data)[ncol]
data <- mutate(data, Observation_number = 1:n()) %>% gather(key = "Group", value = "x", -c(ncol,(ncol+1)))
xname <- "x"
yname <- colnames(y)
group <- "Group"
}else if(ncoly>ncolx&ncolx==1){
data <- data.frame(x,y)
ncol <- ncol(data)
data <- mutate(data, Observation_number = 1:n()) %>% gather(key = "Group", value = "yy", -c(1,(ncol+1)))
xname <- colnames(x)
yname <- "yy"
group <- "Group"
}else if(ncolx==ncoly){
colnames(x) = colnames(y) = paste0("Column ", 1:ncolx)
x <- gather(x, key = "Group", value = "x") %>% mutate(Observation_number = 1:n())
y <- gather(y, key = "Group", value = "yy") %>% mutate(Observation_number = 1:n())
data <- full_join(x, y, by = "Observation_number") %>% rename(Group = Group.x) %>% select(-Group.y)
xname <- "x"
yname <- "yy"
group <- "Group"
}else{
stop("`x`` and `y` must have only 1 or the same number of columns", call. = FALSE)
}
return(list(data=data, xname=xname, yname=yname, group=group, ncolx=ncolx, ncoly=ncoly))
}
x <- rnorm(100,sd=2)
y <- x*0.5+rnorm(100,sd=1)
fit.y <- fitted(lm(y~x))
ggmatclean(x,cbind(y,fit.y))
use_r("gg_pivot_longer")
library(devtools)
use_r("gg_pivot_longer")
iris_sub <- subset(iris, Species == "setosa")
iris_sub[,c(1,3)]
iris_sub[,c(2,4)]
x <- iris_sub[,c(1,3)]
x <- data.frame(x)
x
x <- iris_sub[,c(1,2)]
x
x <- iris_sub[,c(1,1)]
x
x <- iris_sub[,1]
x
x <- iris_sub[,c(1)]
x
x <- iris_sub[,c(0,1)]
x
x <- iris_sub[,1]
x
class(x)
x <- data.frame(x)
class(x)
data <- mutate(x, Observation_number = 1:n())
library(tidyverse)
data <- mutate(x, Observation_number = 1:n())
data
old_namex <- colnames(data)[1]
old_namex
data <- rename(data, new_namex = old_namex)
data
p <- qplot(x = Observation_number, y = new_namex, data = data, geom = geom) + ylab(old_namex) + xlab("Observation Number")
geom = "point"
p <- qplot(x = Observation_number, y = new_namex, data = data, geom = geom) + ylab(old_namex) + xlab("Observation Number")
p
library(tidyverse)
ggmatclean <- function (x, y){
if (!missing(y)){
ncoly <- ncol(as.data.frame(y))
y <- data.frame(y)
}else{
ncoly<-1
}
if (missing(y)){
data <- mutate(x, Observation_number = 1:n()) %>% gather(key = "Group", value = "yy", -(ncolx+1))
xname <- "Observation_number"
yname <- "yy"
group <- "Group"
}else if(ncolx>ncoly&ncoly==1){
data <- data.frame(x,y)
ncol <- ncol(data)
yname <- colnames(data)[ncol]
data <- mutate(data, Observation_number = 1:n()) %>% gather(key = "Group", value = "x", -c(ncol,(ncol+1)))
xname <- "x"
yname <- colnames(y)
group <- "Group"
}else if(ncoly>ncolx&ncolx==1){
data <- data.frame(x,y)
ncol <- ncol(data)
data <- mutate(data, Observation_number = 1:n()) %>% gather(key = "Group", value = "yy", -c(1,(ncol+1)))
xname <- colnames(x)
yname <- "yy"
group <- "Group"
}else if(ncolx==ncoly){
colnames(x) = colnames(y) = paste0("Column ", 1:ncolx)
x <- gather(x, key = "Group", value = "x") %>% mutate(Observation_number = 1:n())
y <- gather(y, key = "Group", value = "yy") %>% mutate(Observation_number = 1:n())
data <- full_join(x, y, by = "Observation_number") %>% rename(Group = Group.x) %>% select(-Group.y)
xname <- "x"
yname <- "yy"
group <- "Group"
}else{
stop("`x`` and `y` must have only 1 or the same number of columns", call. = FALSE)
}
return(list(data=data, xname=xname, yname=yname, group=group, ncolx=ncolx, ncoly=ncoly))
}
iris_sub <- subset(iris, Species == "setosa") %>% head(5)
iris_sub
ggmatclean(iris_sub[,c(1,2)], iris_sub[,c(3,4)])
matplot(iris_sub[,c(1,2)], iris_sub[,c(3,4)])
X <- 1:10
Y=X^2
Z=X^2-2*X
mat <- matplot(X,cbind(Y,Z),pch=c(16,1),xlab="x",ylab="X^2 and X^2-2*X")
class(mat)
ggmatclean(iris_sub[,c(1,2)], iris_sub[,c(3,4)])
iris_sub <- subset(iris, Species == "setosa") %>% head(5)
ggmatclean(iris_sub[,c(1,2)], iris_sub[,c(3,4)])
devtools::document()
devtools::load_all()
devtools::load_all()
iris_sub <- subset(iris, Species == "setosa")
#Only x no Y
x <- iris_sub[,c(2:3)]
ggmatplot(x)
x
x <- iris_sub[c(1:5),c(2:3)]
ggmatplot(x)
x <- iris_sub[,1:3]
y <- iris_sub[,4]
ggmatclean(x,y)
ggmatclean(x)
x <- iris_sub[,1]
y <- iris_sub[,2:3]
ggmatclean(x,y)
x <- iris_sub[,1:2]
y <- iris_sub[,3:4]
x
x <- iris_sub[,1:2]
y <- iris_sub[,3:4]
x
x <- iris_sub[,1:2]
x
iris_sub <- subset(iris, Species == "setosa")[c(1:5),]
x <- iris_sub[,1:2]
y <- iris_sub[,3:4]
x
y
ggmatclean(x,y)
x <- iris_sub[,1]
y <- iris_sub[,2:3]
x
y
ggmatclean(x,y)
devtools::load_all()
x <- iris_sub[,1:2]
y <- iris_sub[,3:4]
ggmatclean()
ggmatclean(x,y)
ggmatclean(x,y)
devtools::load_all()
ggmatclean(x,y)
devtools::load_all()
devtools::load_all()
iris_sub <- subset(iris, Species == "setosa")[c(1:5),]
iris_sub
x <- iris_sub[,c(2:3)]
x
ggmatclean(x)
#' Function to convert a wide dataframe into long format
#'
#' @param data dataframe to pivot.
#' @param names_to a string specifying the name of the column to create from the column names of those being pivoted.
#' @param values_to a string specifying the name of the column to create from the data stored in cell values of the columns being pivoted.
#' @param id_cols columns that uniquely identify observations. Columns to not pivot into longer format.
#'
#' @return a dataframe in long format
#'
#' @examples
#' # Define a data set
#' iris_sub <- subset(iris, Species == "setosa")[1:4]
#' # Use first two columns as ID columns and pivot the second two columns to long format
#' ggpivotlonger(iris_sub, names_to = "Measurement", values_to = "Value", c(1,2))
#' @NoRd
ggpivotlonger <- function (data, names_to = "", values_to = "", id_cols=NULL){
# holder for long format dataframe
long_df <- data.frame(matrix(ncol = 2+length(id_cols), nrow = 0))
colnames(long_df) <-  c(colnames(data[id_cols]),names_to,values_to)
n_widecols <- ncol(data)-length(id_cols)
widecols <- ifelse(is.null(id_cols), data, data[-1*id_cols])
print(widecols)
for(i in 0:nrow(data)-1){
for(j in 1:n_widecols){
if(!is.null(id_cols)){
for(k in 1:length(id_cols)){
long_df[n_widecols*i+j,k] <- data[i+1,id_cols[k]]
}
}
long_df[n_widecols*i+j,names_to] <- colnames(widecols)[j]
long_df[n_widecols*i+j,values_to] <- widecols[i+1,j]
}
}
return(long_df)
}
# ggpivotlonger <- function (data, names_to = "", values_to = "", id_cols){
#
#   if(!missing(id_cols)){
#     long_df <- data.frame(matrix(ncol = 2+length(id_cols), nrow = 0))
#     colnames(long_df) <-  c(colnames(data[id_cols]),names_to,values_to)
#     n_widecols <- ncol(data)-length(id_cols)
#     widecols <- data[-1*id_cols]
#     for(i in 0:nrow(data)-1){
#       for(j in 1:n_widecols){
#         for(k in 1:length(id_cols)){
#           long_df[n_widecols*i+j,k] <- data[i+1,id_cols[k]]
#         }
#         long_df[n_widecols*i+j,names_to] <- colnames(widecols)[j]
#         long_df[n_widecols*i+j,values_to] <- widecols[i+1,j]
#       }
#     }
#   }
#   else{
#     long_df <- data.frame(matrix(ncol = 2, nrow = 0))
#     colnames(long_df) <-  c(names_to,values_to)
#     n_widecols <- ncol(data)
#     widecols <- data
#     for(i in 0:nrow(data)-1){
#       for(j in 1:n_widecols){
#         long_df[n_widecols*i+j,names_to] <- colnames(widecols)[j]
#         long_df[n_widecols*i+j,values_to] <- widecols[i+1,j]
#       }
#     }
#   }
#   return(long_df)
# }
ggmatclean(x)
devtools::load_all()
ggmatclean(x)
devtools::load_all()
ggmatclean(x)
devtools::load_all()
ggmatclean(x)
devtools::load_all()
ggmatclean(x)
devtools::load_all()
iris_sub <- subset(iris, Species == "setosa")[c(1:5),]
x <- iris_sub[,c(2:3)]
x
ggmatclean(x)
x <- iris_sub[,1:3]
y <- iris_sub[,4]
x
y
ggmatclean(x,y)
x <- iris_sub[,1]
y <- iris_sub[,2:3]
x
y
ggmatclean(x,y)
x <- iris_sub[,1:2]
y <- iris_sub[,3:4]
x
y
ggmatclean(x,y)
devtools::load_all()
iris_sub <- subset(iris, Species == "setosa")[c(1:5),]
x <- iris_sub[,c(2:3)]
x
ggmatclean(x)
x <- iris_sub[,1:3]
y <- iris_sub[,4]
ggmatclean(x,y)
x <- iris_sub[,1]
y <- iris_sub[,2:3]
ggmatclean(x,y)
x <- iris_sub[,1:2]
y <- iris_sub[,3:4]
ggmatclean(x,y)
